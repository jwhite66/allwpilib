description = "A C++ and Java library to pass FRC Simulation Messages in and out of Gazebo."

apply plugin: 'cpp'
apply plugin: 'java'
apply plugin: 'com.google.protobuf'
apply plugin: 'edu.wpi.first.NativeUtils'

/* The simulation does not run on real hardware; so we always skip Athena */
ext.skipAthena = true

apply from: "../../config.gradle"

repositories {
      mavenCentral()
}

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.google.protobuf:protobuf-gradle-plugin:+'
    }
}


/* At the time of this writing, the author could not find a pure
   gradle method to build these files; the compilation of the
   generated cpp files seemed to require having a Linux system
   package of libprotobuf-dev.  This invocation of pkg-config is a sort of poor
   man's autoconf for gradle.

   TODO:  Test this on Windows and/or find an alternate strategy. */

def protobuf_version = "pkg-config --modversion protobuf".execute().text.trim()
println "Protobuf version is [${protobuf_version}]"

if (!protobuf_version?.trim()) {
    println "Protobuf is not available. (pkg-config --modversion protobuf failed)"
    protobuf_version = "+"
    if (project.hasProperty("makeSim")) {
        /* Force the build even though we did not find protobuf. */
        println "makeSim set. Forcing build - failure likely."
    }
    else {
        ext.skip_gz_msgs = true
        println "Skipping gz_msgs."
    }
}

tasks.whenTaskAdded { task ->
    task.onlyIf { !project.hasProperty('skip_gz_msgs') }
}

dependencies {
      compile "com.google.protobuf:protobuf-java:${protobuf_version}"
      compile "com.google.protobuf:protoc:${protobuf_version}"
}

/* There is a nice gradle plugin for protobuf, and the protoc tool
   is included; using it simplifies our build process.
   The trick is that we have to use the same version as the system
   copy of libprotobuf-dev */
protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:${protobuf_version}"
    }

    generatedFilesBaseDir = "$buildDir/generated"
    generateProtoTasks {
        all().each { task ->
            task.builtins {
                cpp {
                    outputSubDir = 'simulation/gz_msgs'
                }
            }
        }
    }
}

model {
    components {
        gz_msgs(NativeLibrarySpec) {
            sources {
                cpp {
                    source {
                        srcDir "$buildDir/generated/main/simulation/gz_msgs"
                        builtBy tasks.generateProto
                    }
                    exportedHeaders {
                        srcDir "src/include"
                        srcDir "$buildDir/generated/main"
                    }
                }
            }
        }
    }
}
